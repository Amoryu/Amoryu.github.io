import{_ as e,o as a,c as r,a as d}from"./app-52249f43.js";const h={},t=d(`<h1 id="_01-jsx" tabindex="-1"><a class="header-anchor" href="#_01-jsx" aria-hidden="true">#</a> 01 JSX</h1><h2 id="本质是什么" tabindex="-1"><a class="header-anchor" href="#本质是什么" aria-hidden="true">#</a> 本质是什么？</h2><p>Javascript的语法扩展，充分具备JavaScript的能力</p><p>JSX代码被Babel编译为React.createElement调用，然后ReactElement调用产生虚拟DOM，作为参数传递给ReactDOM.render()渲染生成真实DOM节点</p><h2 id="createelement-type-config-children" tabindex="-1"><a class="header-anchor" href="#createelement-type-config-children" aria-hidden="true">#</a> createElement(type,config,children）</h2><h2 id="reactelement" tabindex="-1"><a class="header-anchor" href="#reactelement" aria-hidden="true">#</a> ReactElement</h2><h2 id="reactdom-render" tabindex="-1"><a class="header-anchor" href="#reactdom-render" aria-hidden="true">#</a> ReactDOM.render</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span>contanier<span class="token punctuation">,</span><span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_02为什么要更改生命周期上-react15" tabindex="-1"><a class="header-anchor" href="#_02为什么要更改生命周期上-react15" aria-hidden="true">#</a> 02为什么要更改生命周期上 React15</h1><p>设计思想，React的大方向</p><h2 id="虚拟dom-核心算法的基石" tabindex="-1"><a class="header-anchor" href="#虚拟dom-核心算法的基石" aria-hidden="true">#</a> 虚拟DOM：核心算法的基石</h2><h2 id="组件化思想" tabindex="-1"><a class="header-anchor" href="#组件化思想" aria-hidden="true">#</a> 组件化思想</h2><p>封闭</p><p>开放：单向数据流</p><p>生命周期：组件的灵魂render与躯干（生命周期方法）</p><p>render执行不会操作真实DOM，只是将渲染的DOM返回</p><h3 id="组件的初始化" tabindex="-1"><a class="header-anchor" href="#组件的初始化" aria-hidden="true">#</a> 组件的初始化</h3><h3 id="组件的更新" tabindex="-1"><a class="header-anchor" href="#组件的更新" aria-hidden="true">#</a> 组件的更新</h3><p>componentReceiveProps不是由props变化触发的，是由父组件的更新触发的</p><p>shouldComponentUpdate（nextProps,)根据返回值决定是否执行后续的生命周期</p><h1 id="_03为什么要更改生命周期下-react17" tabindex="-1"><a class="header-anchor" href="#_03为什么要更改生命周期下-react17" aria-hidden="true">#</a> 03为什么要更改生命周期下 React17</h1><p>react16生命周期</p><p>废弃componentWill Mount，增加getDerivedStateFromProps（代替componentWillReceiveProps)</p><h2 id="getderivedstatefromprops" tabindex="-1"><a class="header-anchor" href="#getderivedstatefromprops" aria-hidden="true">#</a> getDerivedStateFromProps</h2><p>getDerivedStateFromProps的用途，使用props来派生，更新state，更新和挂载都会出现</p><ol><li>静态方法，无法访问this</li><li>接收props和state</li><li>需要一个对象格式的返回值</li></ol><p>基于props派生state</p><p>getSnapshotBeforeUpdate</p><p>组件更新时调用</p><p>componentDidUpdate组件更新后调用</p><p>Fiber是React16对React核心算法的一次重写，使同步的渲染过程变为异步</p><p>render阶段允许暂停终止，和重启，这个阶段</p><h3 id="react16生命周期改造的主要动机" tabindex="-1"><a class="header-anchor" href="#react16生命周期改造的主要动机" aria-hidden="true">#</a> react16生命周期改造的主要动机</h3><p>配合Fiber架构带来的异步渲染机制，确保数据和视图的安全性，确保生命周期方法的行为更加纯粹，可控，可预测</p><h1 id="_04数据是如何流动的上" tabindex="-1"><a class="header-anchor" href="#_04数据是如何流动的上" aria-hidden="true">#</a> 04数据是如何流动的上</h1><h2 id="单向数据流" tabindex="-1"><a class="header-anchor" href="#单向数据流" aria-hidden="true">#</a> 单向数据流</h2><p>组件的state以props形式流动时，只能流向组件树中比自身层级低的组件（父流向子，子流向父通过绑定父组件传递的自身上下文函数，类似于Vue的自定义事件）</p><h2 id="发布订阅模式" tabindex="-1"><a class="header-anchor" href="#发布订阅模式" aria-hidden="true">#</a> 发布订阅模式</h2><p>驱动数据在任意组件流动</p><h1 id="_05数据是如何流动的下" tabindex="-1"><a class="header-anchor" href="#_05数据是如何流动的下" aria-hidden="true">#</a> 05数据是如何流动的下</h1><p>ContextAPI：组件树全局通信的方式</p><p>Provider</p><p>Consumer</p><p>React.createContext</p><h2 id="redux使javascript状态容器-提供可预测的状态管理" tabindex="-1"><a class="header-anchor" href="#redux使javascript状态容器-提供可预测的状态管理" aria-hidden="true">#</a> Redux使JavaScript状态容器，提供可预测的状态管理</h2><p>react组件群里面，组件是群成员，redux则是群文件，供组件读取和写入</p><p>redux整个工作过程中，数据流是严格单向的</p><p>store：只读的，单一的数据源</p><p>action：变化的描述（修改state的意图 ），通知reducer让改变发生</p><p>reducer：负责对变化进行分发和处理，将新的state传给store</p><h1 id="_06hooks的设计动机与工作模式" tabindex="-1"><a class="header-anchor" href="#_06hooks的设计动机与工作模式" aria-hidden="true">#</a> 06Hooks的设计动机与工作模式</h1><p>函数组件和类组件</p><p>函数组件会捕获render内部的状态，是两者最大的不同</p><p>真正把数据和渲染绑定到一起</p><h2 id="_01告别难以理解的class和this" tabindex="-1"><a class="header-anchor" href="#_01告别难以理解的class和this" aria-hidden="true">#</a> 01告别难以理解的class和this</h2><h1 id="_08hooks的工作机制" tabindex="-1"><a class="header-anchor" href="#_08hooks的工作机制" aria-hidden="true">#</a> 08Hooks的工作机制</h1><p>只在函数中调用hooks</p><p>不要再循环，条件或嵌套函数中调用hooks</p><p>要确保hooks在每次渲染时保持同样的执行顺序</p><h2 id="hooks的本质是链表" tabindex="-1"><a class="header-anchor" href="#hooks的本质是链表" aria-hidden="true">#</a> Hooks的本质是链表</h2><h1 id="_09真正理解虚拟dom" tabindex="-1"><a class="header-anchor" href="#_09真正理解虚拟dom" aria-hidden="true">#</a> 09真正理解虚拟DOM</h1><h2 id="虚拟dom是什么" tabindex="-1"><a class="header-anchor" href="#虚拟dom是什么" aria-hidden="true">#</a> 虚拟DOM是什么</h2><p>JS对象</p><p>对真实DOM的描述</p><h2 id="dom操作解决方案" tabindex="-1"><a class="header-anchor" href="#dom操作解决方案" aria-hidden="true">#</a> DOM操作解决方案</h2><p>模板引擎：应用场景局限在“实现高效的字符串拼接”，全量更新导致性能低下</p><p>数据驱动视图：新旧DOM树进行==diff差异化对比==，最后使用==patch函数进行差量更新==</p><h2 id="虚拟dom的价值不在于性能的提升" tabindex="-1"><a class="header-anchor" href="#虚拟dom的价值不在于性能的提升" aria-hidden="true">#</a> 虚拟DOM的价值不在于性能的提升</h2><h2 id="解决了哪些问题" tabindex="-1"><a class="header-anchor" href="#解决了哪些问题" aria-hidden="true">#</a> 解决了哪些问题？</h2><p>研发体验/效率的问题</p><p>跨平台问题</p><h1 id="_10-react15的栈调和reconciler" tabindex="-1"><a class="header-anchor" href="#_10-react15的栈调和reconciler" aria-hidden="true">#</a> 10 React15的栈调和Reconciler</h1><p>栈调和的diff算法其实就是树的深度优先遍历，致命点在于这是同步的</p><p>调和: 使虚拟DOM和真实DOM同步，使之保持一致</p><p>diff: 找出虚拟DOM和真实DOM的不同</p><h2 id="diff策略的设计思想" tabindex="-1"><a class="header-anchor" href="#diff策略的设计思想" aria-hidden="true">#</a> Diff策略的设计思想</h2><p>算法复杂度O(n³)</p><p>树递归的特征</p><h1 id="_11setstate到底是同步还是异步的" tabindex="-1"><a class="header-anchor" href="#_11setstate到底是同步还是异步的" aria-hidden="true">#</a> 11setState到底是同步还是异步的？</h1><p>react通过锁机制进行setState异步管控，在钩子函数以及合成事件中表现为异步</p><p>在setTimeOut中，或者DOM操作中表现为同步</p><h1 id="_12如何理解fiber结构的动机与思想" tabindex="-1"><a class="header-anchor" href="#_12如何理解fiber结构的动机与思想" aria-hidden="true">#</a> 12如何理解Fiber结构的动机与思想</h1><p>react 16.x版本将Diff算法重写，出现Fiber Reconciler</p><p>JS线程与渲染线程必须是互斥的</p><p>Fiber架构的应用目的是实现增量渲染，可中断，可恢复与优先级</p><p>Scheduler ---&gt; Reconciler ---&gt; Rerenderer</p><h1 id="_13react-dom-render是如何串联渲染链路的-上" tabindex="-1"><a class="header-anchor" href="#_13react-dom-render是如何串联渲染链路的-上" aria-hidden="true">#</a> 13React DOM.render是如何串联渲染链路的? 上</h1><h1 id="_14react-dom-render是如何串联渲染链路的-中" tabindex="-1"><a class="header-anchor" href="#_14react-dom-render是如何串联渲染链路的-中" aria-hidden="true">#</a> 14React DOM.render是如何串联渲染链路的? 中</h1><h1 id="_15react-dom-render是如何串联渲染链路的-下" tabindex="-1"><a class="header-anchor" href="#_15react-dom-render是如何串联渲染链路的-下" aria-hidden="true">#</a> 15React DOM.render是如何串联渲染链路的? 下</h1><h1 id="_18redux的设计思想" tabindex="-1"><a class="header-anchor" href="#_18redux的设计思想" aria-hidden="true">#</a> 18Redux的设计思想</h1><p>redux是Flux架构的实现形式</p><h1 id="_21react-router前端路由" tabindex="-1"><a class="header-anchor" href="#_21react-router前端路由" aria-hidden="true">#</a> 21React-Router前端路由</h1><h2 id="前端路由是什么" tabindex="-1"><a class="header-anchor" href="#前端路由是什么" aria-hidden="true">#</a> 前端路由是什么？</h2><p>感知URL的变化，实现一个路由对应一套资源</p><p>拦截用户的刷新操作</p><p>实现思路</p><h2 id="hash模式" tabindex="-1"><a class="header-anchor" href="#hash模式" aria-hidden="true">#</a> hash模式</h2><h2 id="history模式" tabindex="-1"><a class="header-anchor" href="#history模式" aria-hidden="true">#</a> history模式</h2><h1 id="_22如何打造高性能react应用" tabindex="-1"><a class="header-anchor" href="#_22如何打造高性能react应用" aria-hidden="true">#</a> 22如何打造高性能React应用</h1><ol><li><p>shouldComponentUpdate规避冗余更新逻辑</p></li><li><p>PureComponent + immutable.js</p><p>PureComponent是内部封装了shouldComponentUpdate规避冗余更新逻辑的类组件</p></li><li><p>React.momo与useMemo</p><p>React.memo就是函数版的shouldComponentUpdate，控制是否需要重新渲染一个组件</p><p>useMemo控制的时是否需要重复执行某一个逻辑</p></li></ol>`,100),i=[t];function n(c,s){return a(),r("div",null,i)}const o=e(h,[["render",n],["__file","Reactzhishilianluyudicengluoji.html.vue"]]);export{o as default};
