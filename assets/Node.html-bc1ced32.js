import{_ as a,o as n,c as s,a as e}from"./app-52249f43.js";const i={},t=e(`<h2 id="node-js是基于chrome-v8引擎的javascript-后端-的运行环境-使javascript可以进行后端开发" tabindex="-1"><a class="header-anchor" href="#node-js是基于chrome-v8引擎的javascript-后端-的运行环境-使javascript可以进行后端开发" aria-hidden="true">#</a> Node.js是基于Chrome V8引擎的JavaScript（后端）的运行环境，使JavaScript可以进行后端开发</h2><p>JavaScript运行环境：运行环境 也叫 运行时</p><p>以Chrome为例，V8：Chrome的JavaScript解析引擎，性能最好</p><p>浏览器内置的WebAPI ：<strong>DOM BOM Ajax</strong>，因此可以编写JavaScript代码去调用并执行它们，是由运行环境提供的特殊接口，只能在所属的运行环境中被调用</p><p>浏览器是JavaScript的前端运行环境，Node.js是JavaScript的后端运行环境</p><p>Node中无法调用DOM和BOM等浏览器内置API（因为不包含这些API）</p><h2 id="node可以做什么" tabindex="-1"><a class="header-anchor" href="#node可以做什么" aria-hidden="true">#</a> Node可以做什么</h2><ul><li><p>构建Web应用</p></li><li><p>构建跨平台的桌面应用</p></li><li><p>快速构建API接口项目</p></li></ul><h2 id="终端" tabindex="-1"><a class="header-anchor" href="#终端" aria-hidden="true">#</a> 终端</h2><h4 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> cmd</h4><p>功能较为基础</p><h4 id="powershell" tabindex="-1"><a class="header-anchor" href="#powershell" aria-hidden="true">#</a> powershell</h4><p>功能较强大</p><p>window打开powershell：<strong>空白处按下shift键后点击鼠标右键</strong></p><ul><li><h4 id="node执行javascript文件" tabindex="-1"><a class="header-anchor" href="#node执行javascript文件" aria-hidden="true">#</a> node执行JavaScript文件</h4><p>node 文件名</p></li></ul><h1 id="fs文件系统模块" tabindex="-1"><a class="header-anchor" href="#fs文件系统模块" aria-hidden="true">#</a> fs文件系统模块</h1><p>Node.js提供的，用来操作文件的模块</p><ul><li><p><strong>fs.readFile()</strong>：用来读取指定文件中的内容</p><p>fs.redFile(文件路径path，[编码格式]，回调函数)；</p><p>参数一：读取文件的存储路径</p><p>参数二：读取文件时采用的编码格式，一般默认指定交utf8（可选）</p><p>参数三：回调函数，拿到读取失败和成功的结果，err datastr</p></li><li><p><strong>fs.writeFile()</strong>：用来向指定的文件中写入内容</p><p>fs.writeFile(文件路径，要写入的内容，[编码格式]，回调函数)</p><p>参数一：读取文件的存储路径</p><p>参数二：要向指定文件写入的内容</p><p>参数三：读取文件时采用的编码格式，一般默认指定交utf8（可选）</p><p>参数四：回调函数，拿到读取失败的结果err，若写入成功err的值为null</p></li></ul><p>==<strong>注意</strong>==：只能创建文件，不能创建路径（文件所在的文件夹必须存在，否则会报错）</p><p>若已存在相同的文件，则fs.writeFile()创建的文件会覆盖该文件</p><h2 id="路径问题" tabindex="-1"><a class="header-anchor" href="#路径问题" aria-hidden="true">#</a> 路径问题</h2><p>fs模块操作文件时，若提供的操作路径是<strong>相对路径</strong>（以./或../开头），则代码在运行时，会以<strong>执行node命令时所处目录，动态拼接出被操作文件的完整路径，</strong>（不识别node命令后面的路径字符串）</p><h1 id="path路径模块" tabindex="-1"><a class="header-anchor" href="#path路径模块" aria-hidden="true">#</a> path路径模块</h1><ul><li><p><strong>path.join()</strong>：用来将多个路径片段拼接成一个完整的路径字符串</p><p>注意，../会抵消掉一层路径</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> pathstr <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;/a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;/b/c&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;../&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;/d&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pathstr<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//输出\\a\\b\\d</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>path.basename()</strong>：用来从路径字符串中，把文件名解析出来</p><p>参数一，路径字符串</p><p>参数二，要去掉的文件扩展名（可选）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> fpath <span class="token operator">=</span> <span class="token string">&#39;a/b/c/index.js&#39;</span>

<span class="token keyword">let</span> fp <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span>fpath<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//index.js</span>
<span class="token keyword">let</span> fp <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span>fpath<span class="token punctuation">,</span> <span class="token string">&#39;.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//index  删除文件的扩展名</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>path.extname</p><p>获取路径中的扩展名部分</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const path = require(&#39;path&#39;);

const fpath = &#39;a/b/c/index.js&#39;

let fext = path.basename(fpath);		

console.log(fext);			//.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h1 id="http模块" tabindex="-1"><a class="header-anchor" href="#http模块" aria-hidden="true">#</a> http模块</h1><p>基于该模块，手写一个服务器软件，对外提供Web服务</p><p>域名和IP地址</p><p>本地IP ：127.0.0.1 对应的域名为 localhost</p><h2 id="创建最基本的web服务器" tabindex="-1"><a class="header-anchor" href="#创建最基本的web服务器" aria-hidden="true">#</a> 创建最基本的Web服务器</h2><ol><li><h4 id="导入http模块" tabindex="-1"><a class="header-anchor" href="#导入http模块" aria-hidden="true">#</a> 导入http模块</h4></li><li><h4 id="创建服务器实例" tabindex="-1"><a class="header-anchor" href="#创建服务器实例" aria-hidden="true">#</a> 创建服务器实例</h4></li><li><h4 id="为服务器实例绑定request事件-监听来自端口的请求" tabindex="-1"><a class="header-anchor" href="#为服务器实例绑定request事件-监听来自端口的请求" aria-hidden="true">#</a> 为服务器实例绑定request事件,监听来自端口的请求</h4></li><li><h4 id="启动服务器" tabindex="-1"><a class="header-anchor" href="#启动服务器" aria-hidden="true">#</a> 启动服务器</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><h1 id="crypto加密模块" tabindex="-1"><a class="header-anchor" href="#crypto加密模块" aria-hidden="true">#</a> crypto加密模块</h1><h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h1><p>解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程，对整个系统来说，模块是可组合，分解和更换的单元</p><p>遵守固定的规则，把一个大文件拆分成独立并相互依赖的多个小模块</p><h4 id="好处" tabindex="-1"><a class="header-anchor" href="#好处" aria-hidden="true">#</a> 好处</h4><ul><li><p>提高代码复用性和可维护性</p></li><li><p>实现按需加载</p></li></ul><h3 id="node-js中模块的分类" tabindex="-1"><a class="header-anchor" href="#node-js中模块的分类" aria-hidden="true">#</a> Node.js中模块的分类</h3><ul><li>内置模块：fs、path、http</li><li>自定义模块：用户自定义的.js文件</li><li>第三方模块：第三方开发出来的模块。使用前需要下载</li></ul><h4 id="加载模块" tabindex="-1"><a class="header-anchor" href="#加载模块" aria-hidden="true">#</a> 加载模块</h4><p>require()，按需加载内置模块，自定义模块（需要给路径），第三方模块</p><p><u>使用require（）加载其他模块的代码时，会执行被加载模块的代码</u></p><h3 id="模块作用域-模块级别的访问限制" tabindex="-1"><a class="header-anchor" href="#模块作用域-模块级别的访问限制" aria-hidden="true">#</a> 模块作用域（模块级别的访问限制）</h3><p>在自定义模块中定义的变量，方法等成员。只能在当前模块中被访问，能防止全局变量污染的问题</p><h4 id="向外共享模块作用域中的成员" tabindex="-1"><a class="header-anchor" href="#向外共享模块作用域中的成员" aria-hidden="true">#</a> 向外共享模块作用域中的成员</h4><h4 id="module对象" tabindex="-1"><a class="header-anchor" href="#module对象" aria-hidden="true">#</a> module对象</h4><ul><li><p>module.exports对象</p><p>在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用</p><p>（外界用require()方法导入自定义模块时，得到的就是module.exports所指向的对象，默认module.exports为空对象）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//被导入模块</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">&#39;jiahua&#39;</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Node.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>


<span class="token comment">//测试模块</span>
<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./02自定义模块&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//{ username: &#39;jiahua&#39;, sayHello: [Function: sayHello], age: 21 }</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>==<strong>注意点</strong>==：require（）方法导入模块时，导入的结果，永远以module.exports指向的对象为准</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//被导入模块</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">&#39;jiahua&#39;</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Node.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;jiahua&#39;</span><span class="token punctuation">,</span>
    <span class="token function-variable function">learn</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;i am learning Node.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//测试模块</span>
<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./02自定义模块&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//{ name: &#39;jiahua&#39;, learn: [Function: node] }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="exports对象" tabindex="-1"><a class="header-anchor" href="#exports对象" aria-hidden="true">#</a> exports对象</h3><p>exports对象和module.exports对象指向同一个对象，但require（）方法永远都以module.exports指向的对象为准，</p><h2 id="node-js模块化规范" tabindex="-1"><a class="header-anchor" href="#node-js模块化规范" aria-hidden="true">#</a> Node.js模块化规范</h2><p>CommonJS规范，规定了模块的特性和各模块之间如何相互依赖</p><p><strong>规定</strong></p><ul><li>每个模块内部，module变量代表当前模块</li><li>module变量是一个对象，它的exports属性（module.exports）是对外的接口</li><li>加载某个模块，其实是加载该模块的module.exports属性，require（）方法用于加载模块</li></ul><h2 id="npm与包" tabindex="-1"><a class="header-anchor" href="#npm与包" aria-hidden="true">#</a> npm与包</h2><p><strong>==第三方模块==又叫做包</strong></p><p>包是基于内置模块封装出来的，提供了更高级，方便的API，极大提高了开发效率</p><p><strong>包的版本号</strong>：</p><p>​ 三位数字如 ‘2.29.0’</p><ol><li>大版本</li><li>功能版本</li><li>bug修复版本</li><li><strong>注意</strong>：只要前面的数字增长，后面的版本号就要归零</li></ol><h4 id="安装第三方包" tabindex="-1"><a class="header-anchor" href="#安装第三方包" aria-hidden="true">#</a> <strong>安装第三方包</strong></h4><ol><li><p>在npm网站上找到想要的包，复制npm命令</p></li><li><p>在终端下 执行复制的**==（npm i 安装包名称）==**命令进行包的下载</p></li><li><p>在文件中导入该模块</p><p>安装完后，会多出node_module和package_lock_json等文件，不能修改它们，npm会 自动维护它们</p><h4 id="卸载第三方包" tabindex="-1"><a class="header-anchor" href="#卸载第三方包" aria-hidden="true">#</a> 卸载第三方包</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm uninstall 安装包名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>卸载完成后，会自动将dependencies中的记录删除</p></li></ol><h4 id="多人协作的问题" tabindex="-1"><a class="header-anchor" href="#多人协作的问题" aria-hidden="true">#</a> 多人协作的问题</h4><p>多人协作开发，共享源代码时，要剔除node_module目录,创建package.json，（把node_modules文件夹添加到.gitignore忽略文件中）</p><ul><li><h4 id="包管理配置文件" tabindex="-1"><a class="header-anchor" href="#包管理配置文件" aria-hidden="true">#</a> 包管理配置文件</h4></li></ul><p>项目根目录中，必须提供一个package.json的包管理配置文件</p><ul><li><h5 id="快速创建package-json" tabindex="-1"><a class="header-anchor" href="#快速创建package-json" aria-hidden="true">#</a> 快速创建package.json</h5></li></ul><p>​ 新建项目文件夹后，执行该命令（只执行这一次），就可以快速创建package.json这个包管理配置工具</p><p>==注意==：在英文目录下才能成功运行该命令，所以，项目文件夹名称一定要使用英文，且不能出现空格</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>npm init <span class="token operator">-</span>y
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用npm install 命令安装包时，npm包管理工具会自动把包的名称和版本号，记录到package.json中</p><ul><li><p>dependencies节点：记录使用npm install命令安装了哪些第三方包</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm install 安装包名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果某些包<strong>在项目开发阶段和项目上线后都会用到</strong>，则建议把这些包记录到dependencies节点中</p></li><li><p>devDependencies节点</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm install 安装包名称 -D
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果某些包<strong>只在项目开发阶段用到，项目上线后不会用到</strong>，则建议把这些包记录到devDependencies节点中</p></li><li><p>在多人协作开发时，拿到了剔除了node_module的项目后，直接运行npm i 一次性安装package.json中 dependencies节点记录的所有包</p></li></ul><h4 id="下包速度慢的问题" tabindex="-1"><a class="header-anchor" href="#下包速度慢的问题" aria-hidden="true">#</a> 下包速度慢的问题</h4><p>淘宝npm镜像服务器</p><p><strong>镜像</strong>：是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在完全一样的副本就是镜像</p><p>切换下包的镜像源（下包的服务器地址）</p><p>win + R打开cmd终端</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm config get registry	//查看当前的下包镜像源

//切换下包的镜像源为淘宝npm镜像服务器
npm config set registry=https://registry.npm.taobao.org/

//再次执行查看
npm config get registry	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装nrm小工具，快速查看和切换下包的镜像源</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm i nrm -g	//将nrm安装为全局可用的工具

nrm ls   //查看所有可用的下包镜像源头，*表示当前下包镜像源

//nrm use 镜像源
nrm use taobao    //切换为淘宝的镜像源
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目包" tabindex="-1"><a class="header-anchor" href="#项目包" aria-hidden="true">#</a> 项目包</h3><p>被安装到项目的node_modules目录中的包</p><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h4><ul><li><p><strong>开发依赖包</strong>：被记录到devDependencies节点中的包，只在开发期间会用到</p></li><li><p><strong>核心依赖包</strong>：被记录到dependencies节点中的包，开发期间和项目上线后都会用到</p></li></ul><h3 id="全局包" tabindex="-1"><a class="header-anchor" href="#全局包" aria-hidden="true">#</a> 全局包</h3><p>在npm install 安装包时时，使用 -g 参数，则会把包安装为全局包</p><ul><li><p>只有工具性质的包，才有全局安装的必要，可参考官方提供的说明即可</p></li><li><p><strong>i5ting_toc全局包</strong>：将markdown文件转换为HTML页面</p></li></ul><h3 id="规范的包结构" tabindex="-1"><a class="header-anchor" href="#规范的包结构" aria-hidden="true">#</a> 规范的包结构</h3><ul><li>包必须以单独的目录而存在</li><li>包的顶级目录下必须要包含package.json这个包管理配置文件</li><li>package.json中必须包含name,version,main这三个属性，分别代表包的名字，版本号，包的入口</li></ul><h3 id="开发属于自己的包" tabindex="-1"><a class="header-anchor" href="#开发属于自己的包" aria-hidden="true">#</a> 开发属于自己的包</h3><h4 id="需要实现的功能" tabindex="-1"><a class="header-anchor" href="#需要实现的功能" aria-hidden="true">#</a> 需要实现的功能</h4><ol><li>格式化日期</li><li>转移HTML中的特殊字符</li><li>还原HTML中的特殊字符</li></ol><h4 id="初始化包的基本结构" tabindex="-1"><a class="header-anchor" href="#初始化包的基本结构" aria-hidden="true">#</a> 初始化包的基本结构</h4><ol><li>新建文件夹，作为包的根目录</li><li>根目录下，新建以下三个文件 <ol><li>package.json 包管理配置文件</li><li>index.js 包的入口文件</li><li>README.md 包的说明文档</li></ol></li></ol><h5 id="初始化package-json文件" tabindex="-1"><a class="header-anchor" href="#初始化package-json文件" aria-hidden="true">#</a> 初始化package.json文件</h5><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
	<span class="token property">&quot;name&quot;</span><span class="token operator">:</span><span class="token string">&quot;包的名称&quot;</span><span class="token punctuation">,</span>		<span class="token comment">//包的名称不能重复</span>
	<span class="token property">&quot;version&quot;</span><span class="token operator">:</span><span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;main&quot;</span><span class="token operator">:</span><span class="token string">&quot;index.js&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;description&quot;</span><span class="token operator">:</span><span class="token string">&quot;包实现的功能&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;keywords&quot;</span><span class="token operator">:</span><span class="token string">&quot;和包有关的关键词&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;license&quot;</span><span class="token operator">:</span><span class="token string">&quot;ISC&quot;</span>	<span class="token comment">//遵守的许可协议</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在npm上发布自己开发的包" tabindex="-1"><a class="header-anchor" href="#在npm上发布自己开发的包" aria-hidden="true">#</a> 在npm上发布自己开发的包</h3><h4 id="登录npm账号" tabindex="-1"><a class="header-anchor" href="#登录npm账号" aria-hidden="true">#</a> 登录npm账号</h4><p>切换为官方的下包镜像源后，执行npm login命令，输入用户名和密码</p><h4 id="把包发布到npm上" tabindex="-1"><a class="header-anchor" href="#把包发布到npm上" aria-hidden="true">#</a> 把包发布到npm上</h4><p>切换到要发布的包的根目录，执行npm publish命令，则发布成功</p><p>24小时内无法重复发布</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm publish
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="删除已发布的包" tabindex="-1"><a class="header-anchor" href="#删除已发布的包" aria-hidden="true">#</a> 删除已发布的包</h4><p>只能删除在72小时内发布的包，超过72小时后则无法删除</p><p>24小时内无法重复发布已删除的包</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm unpublish 包名 --force
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="模块的加载机制" tabindex="-1"><a class="header-anchor" href="#模块的加载机制" aria-hidden="true">#</a> 模块的加载机制</h3><p>内置模块的优先级最高：出现模块重名时，加载的是内置模块</p><h4 id="自定义模块的加载机制" tabindex="-1"><a class="header-anchor" href="#自定义模块的加载机制" aria-hidden="true">#</a> 自定义模块的加载机制</h4><ul><li><p>必须以./或 ../开头的路径标识符，若没有，Node会将其当作内置模块或第三方模块进行加载</p></li><li><h4 id="若省略了文件扩展名-会按以下顺序加载文件" tabindex="-1"><a class="header-anchor" href="#若省略了文件扩展名-会按以下顺序加载文件" aria-hidden="true">#</a> 若省略了文件扩展名，会按以下顺序加载文件</h4></li><li><p>按照确切的文件名进行加载</p></li><li><p>自动补全.js，.json，.node文件扩展名进行加载</p></li><li><p>否则加载失败，终端报错</p></li></ul><h4 id="第三方模块的加载机制" tabindex="-1"><a class="header-anchor" href="#第三方模块的加载机制" aria-hidden="true">#</a> 第三方模块的加载机制</h4><p>如果没有找到对应的第三方模块，则会逐级目录往上翻进行加载，直到找到对应的模块为止</p><h4 id="目录作为模块" tabindex="-1"><a class="header-anchor" href="#目录作为模块" aria-hidden="true">#</a> 目录作为模块</h4><p>当把目录作为模块标识符，传递给require()进行加载时，有3种加载方式</p><ol><li>在该目录下查找<strong>package.json文件，并查找main属性</strong>，作为require（）的入口</li><li>若没有package.json文件，或者main入口不存在或无法解析，则会试图<strong>加载index.js</strong></li><li>若index.js文件也不存在或无法解析。则终端打印错误信息</li></ol><h1 id="express" tabindex="-1"><a class="header-anchor" href="#express" aria-hidden="true">#</a> express</h1><p>类似NodeJS内置的http模块，提供了快捷创建Web服务器的方法</p><p>内置模块使用起来复杂，开发效率低，而Express是基于http封装出来的，能极大提高开发效率</p><p>Web网站服务器 ：专门对外提供Web网页资源的服务器</p><p>API接口服务器：专门对外提供API接口的服务器</p><p>req.query：客户端查询字符串的形式</p><p>req.params：可用访问到URL中，匹配到的动态参数</p><h2 id="express-static" tabindex="-1"><a class="header-anchor" href="#express-static" aria-hidden="true">#</a> express.static()</h2><p>创建一个静态资源服务器,</p><p>express.static(‘./文件夹’)</p><h4 id="托管多个静态资源" tabindex="-1"><a class="header-anchor" href="#托管多个静态资源" aria-hidden="true">#</a> 托管多个静态资源</h4><p>访问静态资源时，express.static（）会按照先后顺序查找所需的文件</p><h1 id="express路由" tabindex="-1"><a class="header-anchor" href="#express路由" aria-hidden="true">#</a> Express路由</h1><p>在express中，路由就是映射关系</p><p>**客户端的请求 ** 和 <strong>服务器处理函数之间</strong>的映射关系</p><p>express路由由3部分组成：请求的类型，请求的url地址，处理函数</p><h2 id="模块化路由" tabindex="-1"><a class="header-anchor" href="#模块化路由" aria-hidden="true">#</a> 模块化路由</h2><p>当一个请求到达Express服务器之后，可用连续调用多个中间件，从而对这次请求进行预处理</p><h3 id="express中间件-middleware" tabindex="-1"><a class="header-anchor" href="#express中间件-middleware" aria-hidden="true">#</a> Express中间件（Middleware）</h3><p>本质上是一个function处理函数，function（ , , next)中间件的形参列表中，必须包含next参数</p><p>next函数是实现多个中间件连续调用的关键，表示把流转关系转交给下一个中间件或路由</p><p><strong>==注意==：</strong></p><ul><li><strong>一定要在路由之前定义中间件</strong></li><li>执行完中间件的业务代码后，<strong>一定要调用next()函数</strong></li><li>为防止代码逻辑混乱，<strong>next()后面不要写额外的代码</strong></li></ul><h4 id="中间件函数" tabindex="-1"><a class="header-anchor" href="#中间件函数" aria-hidden="true">#</a> 中间件函数</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">mw</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//一系列处理</span>
	<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="全局生效的中间件" tabindex="-1"><a class="header-anchor" href="#全局生效的中间件" aria-hidden="true">#</a> 全局生效的中间件</h4><p>使用app.use()定义的中间件</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>app.use(function(req,res,next){
	//一系列处理
	next();
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="局部生效的中间件" tabindex="-1"><a class="header-anchor" href="#局部生效的中间件" aria-hidden="true">#</a> 局部生效的中间件</h4><p>不使用app.use()定义的中间件</p><p>定义多个局部中间件</p><p>在路由中添加多个中间件函数作为参数，或放到数组中作为参数</p><h4 id="中间件的作用" tabindex="-1"><a class="header-anchor" href="#中间件的作用" aria-hidden="true">#</a> 中间件的作用</h4><p>多个中间件之间，共享同一份req和res,可用在上有中间件中，同一为req或res对象添加自定义的属性或方法，供下游的中间件或路由进行使用</p><h4 id="定义多个全局中间件" tabindex="-1"><a class="header-anchor" href="#定义多个全局中间件" aria-hidden="true">#</a> 定义多个全局中间件</h4><p>可用用app.use()连续定义多个中间件，<strong>客户端请求到达服务器之后</strong>，会按照<strong>中间件定义的先后顺序</strong>依次进行调用</p><h4 id="错误级别的中间件" tabindex="-1"><a class="header-anchor" href="#错误级别的中间件" aria-hidden="true">#</a> 错误级别的中间件</h4><p>用于捕获错误，且==必须注册在所有路由之后==</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>app.use((err,req,res,next){
	console.log(&quot;捕获到一个错误&quot;+err.message)
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="express内置的中间件" tabindex="-1"><a class="header-anchor" href="#express内置的中间件" aria-hidden="true">#</a> express内置的中间件</h4><ul><li><p><strong>express.static()</strong>：快速托管静态资源的内置中间件（无兼容性）</p></li><li><p><strong>express.json()</strong>：解析JSON格式的请求体数据（有兼容性，仅在4.16.0以后版本可用）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>express.urlenccoded</strong>：解析URL-encoded格式的请求体数据（有兼容性，仅在4.16.0以后版本可用）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">extended</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h4 id="第三方中间件" tabindex="-1"><a class="header-anchor" href="#第三方中间件" aria-hidden="true">#</a> 第三方中间件</h4><p>通过npm install下载中间件</p><p>require导入中间件</p><p>调用app.use()注册并使用定义中间件</p><h4 id="自定义中间件" tabindex="-1"><a class="header-anchor" href="#自定义中间件" aria-hidden="true">#</a> 自定义中间件</h4><p><strong>querystring模块</strong>，专门用来处理查询字符串，将其解析为对象</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const qs=require(&#39;querystring&#39;)
const body = qs.parse(str)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="编写接口" tabindex="-1"><a class="header-anchor" href="#编写接口" aria-hidden="true">#</a> 编写接口</h1><p>CORS跨域资源共享</p><p>使用CORS中间件解决跨域问题，只在服务端进行配置，</p><p><strong>预检请求</strong>：</p><ul><li><p>除GET，POST，HEAD之外的请求</p></li><li><p>包含自定义头部字段的请求</p></li><li><p>发送了application/json格式的数据</p></li></ul><p>服务器响应了遇见请求后，才会发送真正的请求，并携带真实的数据</p><h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h1><p>SQL：结构化查询语言(Structured Query Language)，专门用来访问和处理数据库的编程语言，以编程的形式，操作数据库里面的数据</p><p>SQL的3个关键点</p><ol><li>是一门数据库编程语言</li><li>使用SQL语言编写出来的代码，叫做SQL语句</li><li>SQL语言只能在<strong>关系型数据库</strong>中使用（如MySQL，Oracle，SQL Server）</li><li>SQL语句中的关键字对大小写不敏感（不区分大小写）</li></ol><h2 id="sql语句" tabindex="-1"><a class="header-anchor" href="#sql语句" aria-hidden="true">#</a> SQL语句</h2><p>Select语句</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select 列名 from 表名 where 条件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Insert into语句</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>insert into 表名 (列名) values (要插入的值)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Update语句</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>update 表名 set 列名称 = 新值 where 列名称 = 旧值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>delete语句</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>delete from 表名 (where 列名 = 要删除的值)   -- 不加where子句，会删除整张表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="子句" tabindex="-1"><a class="header-anchor" href="#子句" aria-hidden="true">#</a> 子句</h3><h4 id="where子句" tabindex="-1"><a class="header-anchor" href="#where子句" aria-hidden="true">#</a> where子句</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
select 列名 from 表名 where 列 运算符 值

insert into 表名 (列名) values (要插入的值)

update 表名 set 列名称 = 新值 where 列名称 运算符 旧值

delete from 表名 where 列名 = 要删除的值

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h3><h4 id="order-by子句" tabindex="-1"><a class="header-anchor" href="#order-by子句" aria-hidden="true">#</a> order by子句</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="and-和or运算符" tabindex="-1"><a class="header-anchor" href="#and-和or运算符" aria-hidden="true">#</a> and 和or运算符</h4><p>**and：**必须同时满足多个条件</p><p>**or：**只要满足任意一个条件即可</p><h2 id="mysql模块" tabindex="-1"><a class="header-anchor" href="#mysql模块" aria-hidden="true">#</a> mysql模块</h2><p>db.query</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>标记删除</strong>：给记录添加status删除标记，使用update语句修改这个标记，而不是真正删除这个记录</p><h1 id="web开发模式" tabindex="-1"><a class="header-anchor" href="#web开发模式" aria-hidden="true">#</a> Web开发模式</h1><h3 id="基于服务端渲染的传统模式" tabindex="-1"><a class="header-anchor" href="#基于服务端渲染的传统模式" aria-hidden="true">#</a> 基于服务端渲染的传统模式</h3><p>服务器把发送给客户端的HTML页面，</p><p>优点：</p><ul><li><p>前端耗时少</p></li><li><p>有利于SEO</p></li></ul><p>缺点</p><ul><li>占用服务器端资源</li><li>不利于前后端分离，开发效率低</li></ul><h3 id="前后端分离的模式" tabindex="-1"><a class="header-anchor" href="#前后端分离的模式" aria-hidden="true">#</a> 前后端分离的模式</h3><p>是一种依赖于Ajax技术的广泛应用，后端只负责提供API接口，前端使用Ajax调用接口</p><p>优点</p><ul><li>开发体验好，前端专注页面开发，后端专注API开发</li><li>用户体验好</li><li>减轻了服务器端渲染压力</li></ul><p>缺点</p><ul><li>不利于SEO（Vue,React框架的SSR可以很好解决SEO问题）</li></ul><h3 id="如何选择web开发模式" tabindex="-1"><a class="header-anchor" href="#如何选择web开发模式" aria-hidden="true">#</a> 如何选择Web开发模式</h3><p>需要良好的SEO，没有复杂交互，服务器渲染</p><p>交互性强，不需要考虑SEO，前后端分离</p><h1 id="身份认证" tabindex="-1"><a class="header-anchor" href="#身份认证" aria-hidden="true">#</a> 身份认证</h1><h4 id="不同开发模式下的身份认证" tabindex="-1"><a class="header-anchor" href="#不同开发模式下的身份认证" aria-hidden="true">#</a> 不同开发模式下的身份认证</h4><p>服务端渲染使用 <strong>session认证机制</strong></p><p>前后端分离 使用 <strong>jwt认证机制</strong></p><h2 id="session认证机制" tabindex="-1"><a class="header-anchor" href="#session认证机制" aria-hidden="true">#</a> Session认证机制</h2><p>HTTP协议的无状态性：</p><p>客户端的每次HTTP请求都是独立的，连续多个请求没有直接的关系，服务器不会主动保留每次HTTP请求的状态</p><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> Cookie</h3><p>是存储在用户浏览器中<strong>一段不超过4KB的字符串</strong>，由一个名称（name），一个值（value）和其他几个用于控制Cookie有效期，安全性，使用范围的可选属性组成</p><p>不同域名下的Cookie各自独立，每次客户端发器请求时，会自动把当前域名下未过期的Cookie一同发送到服务器</p><p>特性：自动发送，域名独立，过期时限，4KB限制</p><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p>客户端第一次请求服务器时，服务器<strong>通过响应头的形式</strong>，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存到浏览器中</p><p>以后，每次客户端向服务器发请求时，浏览器会自动将身份认证相关的cookie，通过请求头的形式发送给服务器，服务器通过Cookie对客户端进行身份认证。</p><h3 id="不具有安全性" tabindex="-1"><a class="header-anchor" href="#不具有安全性" aria-hidden="true">#</a> 不具有安全性</h3><p>Cookie存储在浏览器中，浏览器提供了读写Cookie的API，因此Cookie很容易被伪造</p><p><strong>一定不能用Cookie存储重要且隐私的数据</strong></p><h4 id="提高身份认证的安全性" tabindex="-1"><a class="header-anchor" href="#提高身份认证的安全性" aria-hidden="true">#</a> 提高身份认证的安全性</h4><h3 id="session的工作原理" tabindex="-1"><a class="header-anchor" href="#session的工作原理" aria-hidden="true">#</a> Session的工作原理</h3><h4 id="session中间件" tabindex="-1"><a class="header-anchor" href="#session中间件" aria-hidden="true">#</a> session中间件</h4><p><strong>express-session中间件</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;express-session&#39;</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">session</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">secret</span><span class="token operator">:</span> <span class="token string">&#39;javascript&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">resave</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">saveUninitialized</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="向session中存数据" tabindex="-1"><a class="header-anchor" href="#向session中存数据" aria-hidden="true">#</a> 向session中存数据</h4><p>req.session</p><p><strong>清空session</strong></p><p>req.session.destroy() 不会清除所有人的session，只会清空当前用户的session</p><h3 id="session认证的局限性" tabindex="-1"><a class="header-anchor" href="#session认证的局限性" aria-hidden="true">#</a> Session认证的局限性</h3><p>当前端请求后端接口不存在跨域问题时，推荐使用session</p><h2 id="jwt-json-web-token" tabindex="-1"><a class="header-anchor" href="#jwt-json-web-token" aria-hidden="true">#</a> JWT （Json Web Token)</h2><p>跨域认证解决方案</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h4><p>服务器端收到用户信息后，机械能验证，经过加密之后生成Token字符串，响应给客户端，客户端将其存储在Local Storage或SessionStorage中</p><h4 id="组成部分" tabindex="-1"><a class="header-anchor" href="#组成部分" aria-hidden="true">#</a> 组成部分</h4><p>JWT由三部分 <strong>Header， Payload， Signature</strong>组成</p><ul><li><p><strong>Payload才是真正的用户信息</strong>，时用户信息经过加密之后生成的字符串</p></li><li><p>Header和Signature是安全性相关的部分，只是为了保证Token的安全性</p></li></ul><h4 id="使用方式" tabindex="-1"><a class="header-anchor" href="#使用方式" aria-hidden="true">#</a> 使用方式</h4><p>客户端收到服务器返回的JWT之后，通常会将其存储在localStorage或sessionStorage中</p><p>客户端每次与服务器通信时，都要带上JWT字符串<strong>推荐的做法是把JWT放在http请求头的Authorization字段</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Authorization:Bearer &lt;token&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装JWT相关的包：jsonwebtoken，express-jwt</p><ul><li>jsonwebtoken：用于生成JWT字符串（浏览器端）</li><li>express-jwt：用于将JWT字符串解析还原成JSON对象（服务器端）</li></ul><h1 id="中间件" tabindex="-1"><a class="header-anchor" href="#中间件" aria-hidden="true">#</a> 中间件</h1><ol><li><h4 id="什么是中间件" tabindex="-1"><a class="header-anchor" href="#什么是中间件" aria-hidden="true">#</a> 什么是中间件</h4></li></ol><p>中间件（Middleware ），特指业务流程的中间处理环节</p><ol start="2"><li><h4 id="中间件的调用流程" tabindex="-1"><a class="header-anchor" href="#中间件的调用流程" aria-hidden="true">#</a> 中间件的调用流程</h4><p>当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</p></li><li><h4 id="express-中间件的格式" tabindex="-1"><a class="header-anchor" href="#express-中间件的格式" aria-hidden="true">#</a> Express 中间件的格式 ：</h4><p>本质上就是一个 function 处理函数</p></li><li><h4 id="next-函数的作用" tabindex="-1"><a class="header-anchor" href="#next-函数的作用" aria-hidden="true">#</a> next 函数的作用</h4><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由</p></li></ol><h3 id="中间件的5个使用注意事项" tabindex="-1"><a class="header-anchor" href="#中间件的5个使用注意事项" aria-hidden="true">#</a> 中间件的5个使用注意事项</h3><ol><li>一定要在路由之前注册中间件</li><li>客户端发送过来的请求，可以连续调用多个中间件进行处理</li><li>执行完中间件的业务代码之后，不要忘记调用 next() 函数</li><li>为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</li></ol><h3 id="中间件的分类" tabindex="-1"><a class="header-anchor" href="#中间件的分类" aria-hidden="true">#</a> 中间件的分类</h3><p>1.应用级别的中间件</p><ol start="2"><li>路由级别的中间件</li><li>错误级别的中间件</li><li>Express 内置的中间件</li><li>第三方的中间件</li></ol>`,260),p=[t];function r(l,d){return n(),s("div",null,p)}const c=a(i,[["render",r],["__file","Node.html.vue"]]);export{c as default};
