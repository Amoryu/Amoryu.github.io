import{_ as a,o as e,c as n,a as s}from"./app-52249f43.js";const t={},i=s(`<h2 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> HTTP协议</h2><blockquote><p>超文本传输协议: <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</p></blockquote><h2 id="web资源" tabindex="-1"><a class="header-anchor" href="#web资源" aria-hidden="true">#</a> Web资源</h2><blockquote><p>所有能够提供Web内容的东西都是Web资源，包含静态文件和软件程序</p><p>HTTP是无状态的，非持久化的</p></blockquote><h2 id="媒体类型" tabindex="-1"><a class="header-anchor" href="#媒体类型" aria-hidden="true">#</a> 媒体类型</h2><blockquote><p><strong>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型</strong>，中间由一条斜杠来分隔。</p><p>HTTP会给每种要通过Web传输的对象都打上了名为MIME类型（MIME type）的数据格式标签。</p></blockquote><h2 id="uri-统一资源标识符" tabindex="-1"><a class="header-anchor" href="#uri-统一资源标识符" aria-hidden="true">#</a> URI：统一资源标识符</h2><p><strong>URI：唯一标识并定位信息资源，是一个==通用的概念，由两个主要的子集URL和URN构成==</strong></p><p>如今，几乎所有URI都是URL</p><p>**统一资源定位符（URL）**是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。它们可以==明确说明如何从一个精确、固定的位置获取资源。==</p><h4 id="http的url中没有端口号时-可以假设默认端口号是80" tabindex="-1"><a class="header-anchor" href="#http的url中没有端口号时-可以假设默认端口号是80" aria-hidden="true">#</a> ==HTTP的URL中没有端口号时，可以假设默认端口号是80==</h4><h2 id="http事务" tabindex="-1"><a class="header-anchor" href="#http事务" aria-hidden="true">#</a> HTTP事务</h2><blockquote><p>一个HTTP事务由一条（从客户端发往服务器的）<strong>请求命令</strong>和一个（从服务器发回客户端的）<strong>响应结果</strong>组成。这种通信是通过名为HTTP报文（HTTP message）的格式化数据块进行的</p></blockquote><h2 id="http方法" tabindex="-1"><a class="header-anchor" href="#http方法" aria-hidden="true">#</a> HTTP方法</h2><ol><li><h4 id="get-请求服务器向客户端发送命名资源" tabindex="-1"><a class="header-anchor" href="#get-请求服务器向客户端发送命名资源" aria-hidden="true">#</a> GET：请求服务器向客户端发送命名资源</h4></li><li><h4 id="post-将客户端数据发送到一个服务器网关应用程序" tabindex="-1"><a class="header-anchor" href="#post-将客户端数据发送到一个服务器网关应用程序" aria-hidden="true">#</a> POST：将客户端数据发送到一个服务器网关应用程序</h4><p>POST方法起初是用来向服务器输入数据的。通常来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理</p></li><li><h4 id="put-将来自客户端的数据存储到一个命名的服务器资源中去" tabindex="-1"><a class="header-anchor" href="#put-将来自客户端的数据存储到一个命名的服务器资源中去" aria-hidden="true">#</a> PUT：将来自客户端的数据存储到一个命名的服务器资源中去</h4><p>PUT方法的语义就是==让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档==，或者，如果那个URL已经存在的话，就用这个主体来替代它。</p></li><li><h4 id="delete-从服务器中删除命名资源" tabindex="-1"><a class="header-anchor" href="#delete-从服务器中删除命名资源" aria-hidden="true">#</a> DELETE：从服务器中删除命名资源</h4></li><li><h4 id="head-仅发送命名资源响应中的http首部" tabindex="-1"><a class="header-anchor" href="#head-仅发送命名资源响应中的http首部" aria-hidden="true">#</a> HEAD：仅发送命名资源响应中的HTTP首部</h4><p>HEAD方法与GET方法的行为很类似，但==服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查==</p><blockquote><ol><li>在不获取资源的情况下了解资源的情况（比如，判断其类型）；</li><li>通过查看响应中的状态码，看看某个对象是否存在；</li><li>通过查看首部，测试资源是否被修改了。</li></ol></blockquote></li><li><h4 id="trace-主要用于诊断-验证请求是否如愿穿过了请求-响应链。可以用来查看代理和其他应用程序对用户请求所产生效果。" tabindex="-1"><a class="header-anchor" href="#trace-主要用于诊断-验证请求是否如愿穿过了请求-响应链。可以用来查看代理和其他应用程序对用户请求所产生效果。" aria-hidden="true">#</a> TRACE：主要用于诊断；验证请求是否如愿穿过了请求/响应链。可以用来查看代理和其他应用程序对用户请求所产生效果。</h4><p>TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过</p></li><li><h4 id="options-请求web服务器告知其支持的各种功能" tabindex="-1"><a class="header-anchor" href="#options-请求web服务器告知其支持的各种功能" aria-hidden="true">#</a> OPTIONS：请求Web服务器告知其支持的各种功能</h4><p>跨域时，发送复杂请求前，浏览器就会先向服务器发送OPTIONS请求，</p></li></ol><h2 id="常见的状态码" tabindex="-1"><a class="header-anchor" href="#常见的状态码" aria-hidden="true">#</a> 常见的状态码</h2><ol><li><h3 id="_1xx-信息性状态码-http-1-1引入" tabindex="-1"><a class="header-anchor" href="#_1xx-信息性状态码-http-1-1引入" aria-hidden="true">#</a> 1XX：信息性状态码（HTTP/1.1引入）</h3><p>客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用100 Continue。</p></li><li><h3 id="_2xx-成功" tabindex="-1"><a class="header-anchor" href="#_2xx-成功" aria-hidden="true">#</a> 2xx：成功</h3></li><li><h3 id="_3xx-重定向-资源已经被移动到别的位置" tabindex="-1"><a class="header-anchor" href="#_3xx-重定向-资源已经被移动到别的位置" aria-hidden="true">#</a> 3xx：重定向，资源已经被移动到别的位置</h3><blockquote><p><strong>302</strong>：请求的URL已被移除（资源被移动），客户端应该使用响应首部的Location给出的URL临时定位资源，后续请求仍使用旧的URL</p><p><strong>303</strong>：允许POST请求的响应将客户端定向到某个资源上去</p><p><strong>307</strong>：作用与302相同，仅供HTTP/1.1使用（HTTP/1.1规范指出，对于HTTP/1.1客户端，用307状态码取代302状态码来进行临时重定向。这样服务器就可以将302状态码保留起来，为HTTP/1.0客户端使用了。）</p></blockquote><p>重定向状态码==要么告知客户端使用替代位置来访问他们所感兴趣的资源==，要么就==提供一个替代的响应而不是资源的内容==。如果资源已被移动，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪里找到它</p><p>通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。比如，HTTP应用程序可以查看其资源的本地副本是否仍然是最新的，或者在源端服务器上资源是否被修改过</p></li><li><h3 id="_4xx-找不到资源-客户端的请求出错" tabindex="-1"><a class="header-anchor" href="#_4xx-找不到资源-客户端的请求出错" aria-hidden="true">#</a> 4xx：找不到资源，客户端的请求出错</h3><p>401：Unauthorized （未授权）</p></li><li><h3 id="_500-服务器错误" tabindex="-1"><a class="header-anchor" href="#_500-服务器错误" aria-hidden="true">#</a> 500：服务器错误</h3></li></ol><h2 id="http报文" tabindex="-1"><a class="header-anchor" href="#http报文" aria-hidden="true">#</a> HTTP报文</h2><blockquote><p><strong>HTTP报文是由一行一行的简单字符串组成的。HTTP报文都是纯文本</strong></p></blockquote><h4 id="三个组成部分" tabindex="-1"><a class="header-anchor" href="#三个组成部分" aria-hidden="true">#</a> 三个组成部分</h4><ul><li>每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：<strong>对报文进行描述的起始行（start line）、包含属性的首部（header）块，以及可选的、包含数据的主体（body）部分。</strong></li></ul><blockquote><h4 id="起始行" tabindex="-1"><a class="header-anchor" href="#起始行" aria-hidden="true">#</a> 起始行</h4></blockquote><h3 id="首部-和方法配合工作-共同决定了客户端和服务器能做什么事情" tabindex="-1"><a class="header-anchor" href="#首部-和方法配合工作-共同决定了客户端和服务器能做什么事情" aria-hidden="true">#</a> 首部：和方法配合工作，共同决定了客户端和服务器能做什么事情</h3><ol><li><h4 id="通用首部-既可以出现在请求报文中-也可以出现在响应报文中。" tabindex="-1"><a class="header-anchor" href="#通用首部-既可以出现在请求报文中-也可以出现在响应报文中。" aria-hidden="true">#</a> 通用首部：既可以出现在请求报文中，也可以出现在响应报文中。</h4><table><thead><tr><th>Connection</th><th>允许客户端和服务器指定与请求/响应连接有关的选项</th></tr></thead><tbody><tr><td>Date</td><td>提供日期和时间标志，说明报文是什么时间创建的</td></tr><tr><td>MIME-Version</td><td>给出了发送端使用的MIME版本</td></tr><tr><td>Trailer</td><td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td></tr><tr><td>Transfer-Encoding</td><td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td></tr><tr><td>Update</td><td>给出了发送端可能想要“升级”使用的新版本或协议</td></tr><tr><td>Via</td><td>显示了报文经过的中间节点(代理、网关)</td></tr></tbody></table></li><li><h4 id="请求首部-用于说明是谁或什么在发送请求、请求源自何处-或者客户端的喜好及能力" tabindex="-1"><a class="header-anchor" href="#请求首部-用于说明是谁或什么在发送请求、请求源自何处-或者客户端的喜好及能力" aria-hidden="true">#</a> 请求首部：用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力</h4><ol><li><h4 id="accept首部" tabindex="-1"><a class="header-anchor" href="#accept首部" aria-hidden="true">#</a> Accept首部</h4><p>用来告知服务器客户端会接受与其请求相符的任意媒体类型==</p><p>Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西</p></li><li><h4 id="条件请求首部" tabindex="-1"><a class="header-anchor" href="#条件请求首部" aria-hidden="true">#</a> 条件请求首部</h4></li><li><h4 id="安全请求首部" tabindex="-1"><a class="header-anchor" href="#安全请求首部" aria-hidden="true">#</a> 安全请求首部</h4></li><li><h4 id="代理请求首部" tabindex="-1"><a class="header-anchor" href="#代理请求首部" aria-hidden="true">#</a> 代理请求首部</h4></li><li><h4 id="其他首部" tabindex="-1"><a class="header-anchor" href="#其他首部" aria-hidden="true">#</a> 其他首部</h4></li></ol></li><li><h4 id="响应首部-提供更多有关响应的信息。" tabindex="-1"><a class="header-anchor" href="#响应首部-提供更多有关响应的信息。" aria-hidden="true">#</a> 响应首部：提供更多有关响应的信息。</h4><p>Server首部就用来告知客户端它在与一个版本1.0的Tiki-Hut服务器进行交互：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">Server</span><span class="token punctuation">:</span> Tiki<span class="token punctuation">-</span>Hut/1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><h4 id="实体首部-描述主体的长度和内容-或者资源自身。" tabindex="-1"><a class="header-anchor" href="#实体首部-描述主体的长度和内容-或者资源自身。" aria-hidden="true">#</a> 实体首部：描述主体的长度和内容，或者资源自身。</h4><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">Content-Type</span><span class="token punctuation">:</span> text/html; charset=iso<span class="token punctuation">-</span>latin<span class="token punctuation">-</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><h4 id="扩展首部-规范中没有定义的新首部。" tabindex="-1"><a class="header-anchor" href="#扩展首部-规范中没有定义的新首部。" aria-hidden="true">#</a> 扩展首部：规范中没有定义的新首部。&gt;</h4></li></ol><h4 id="实体-主体部分" tabindex="-1"><a class="header-anchor" href="#实体-主体部分" aria-hidden="true">#</a> 实体（主体部分）</h4><p>实体的主体是HTTP报文的负荷。就是HTTP要传输的内容。</p><h4 id="报文流" tabindex="-1"><a class="header-anchor" href="#报文流" aria-hidden="true">#</a> 报文流</h4><p>HTTP报文会像河水一样流动。==不管是请求报文还是响应报文，所有报文都会向下游（downstream）流动==。==<strong>所有报文的发送者都在接收者的上游（upstream）</strong>==</p><h4 id="请求报文" tabindex="-1"><a class="header-anchor" href="#请求报文" aria-hidden="true">#</a> 请求报文</h4><p>格式</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>method</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>request-URL</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>		//方法  请求的URL  HTTP版本
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>headers</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entity-body</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="响应报文" tabindex="-1"><a class="header-anchor" href="#响应报文" aria-hidden="true">#</a> 响应报文</h4><p>格式</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>status</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>reason-phrase</span><span class="token punctuation">&gt;</span></span>		//HTTP版本  状态码   原因短语
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>headers</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entity-body</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="http版本号" tabindex="-1"><a class="header-anchor" href="#http版本号" aria-hidden="true">#</a> HTTP版本号</h4><p><strong>版本号不会被当作小数来处理。版本中的每个数字（比如HTTP/1.0中的1和0）都会被当作一个单独的数字来处理</strong>。因此，在比较HTTP版本时，每个数字都必须单独进行比较，以便确定哪个版本更高。==比如，HTTP/2.22就比HTTP/2.3的版本要高，因为22比3大。==</p><h2 id="连接" tabindex="-1"><a class="header-anchor" href="#连接" aria-hidden="true">#</a> 连接</h2><p>步骤</p><ol><li>浏览器通过==DNS解析==，从URL中解析出服务器的IP地址和端口号</li><li>浏览器与服务器==建立一条TCP连接==</li><li>浏览器向该服务器==发送HTTP请求报文==</li><li>服务器接收到该请求报文，向浏览器==回送一条响应报文==</li><li>==关闭连接，==浏览器将获取到的资源显示给用户</li></ol><h3 id="tcp-ip" tabindex="-1"><a class="header-anchor" href="#tcp-ip" aria-hidden="true">#</a> TCP/IP</h3><p>三次握手</p><p>客户端向服务器发起TCP连接，携带SYN标记1</p><p>服务器收到连接请求并接收请求，向客户端回送一个TCP分组，分组中的SYN和ACK都被置位</p><p>客户端向服务器回送一条确认信息，通知服务器连接已建立</p><h4 id="慢启动-具有拥塞控制特性" tabindex="-1"><a class="header-anchor" href="#慢启动-具有拥塞控制特性" aria-hidden="true">#</a> 慢启动（具有拥塞控制特性）</h4><p>会限制连接初始时的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度</p><p>作用是：限制了一个TCP端点在任意时刻可以传输的分组数</p><h2 id="web的结构组件" tabindex="-1"><a class="header-anchor" href="#web的结构组件" aria-hidden="true">#</a> Web的结构组件</h2><ol><li><h3 id="代理-位于客户端和服务器之间的http中间实体" tabindex="-1"><a class="header-anchor" href="#代理-位于客户端和服务器之间的http中间实体" aria-hidden="true">#</a> 代理：位于客户端和服务器之间的HTTP中间实体</h3><p>HTTP代理服务器，这是Web安全、应用集成以及性能优化的重要组成模块。</p><p>==代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器==（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。</p></li><li><h3 id="缓存-http的仓库-保存常用页面的副本" tabindex="-1"><a class="header-anchor" href="#缓存-http的仓库-保存常用页面的副本" aria-hidden="true">#</a> 缓存：HTTP的仓库，保存常用页面的副本</h3><p>Web缓存（Web cache）或代理缓存（proxy cache）是==一种特殊的HTTP代理服务器==，可以将经过代理传送的常用文档复制保存起来</p></li><li><h3 id="网关-连接其他应用程序的特殊web服务器" tabindex="-1"><a class="header-anchor" href="#网关-连接其他应用程序的特殊web服务器" aria-hidden="true">#</a> 网关：连接其他应用程序的特殊Web服务器</h3><p>网关（gateway）是==一种特殊的服务器，作为其他服务器的中间实体使用。<strong>通常用于将HTTP流量转换成其他的协议</strong>==。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p></li><li><h3 id="隧道" tabindex="-1"><a class="header-anchor" href="#隧道" aria-hidden="true">#</a> 隧道</h3><p>HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。</p></li><li><h3 id="agent代理" tabindex="-1"><a class="header-anchor" href="#agent代理" aria-hidden="true">#</a> Agent代理</h3><p>用户Agent代理（或者简称为Agent代理）是==代表用户发起HTTP请求的客户端程序==。</p><p>所有发布Web请求的应用程序都是HTTP Agent代理。Web浏览器就是一种HTTP Agent代理</p></li></ol><h2 id="url" tabindex="-1"><a class="header-anchor" href="#url" aria-hidden="true">#</a> URL</h2><p>http://www.joes-hardware.com/seasonal/index-fall.html</p><ol><li>URL的第一部分（http）是URL方案（scheme）。方案可以==告知Web客户端怎样访问资源==。在这个例子中，URL说明要使用HTTP协议。·</li><li>URL的第二部分（www.joes-hardware.com）指的是==服务器的位置==。告知Web客户端资源位于何处。·</li><li>URL的第三部分（/seasonal/index-fall.html）是==资源路径==。说明了请求的是服务器上哪个特定的本地资源。</li></ol><p><strong>总结：我希望使用HTTP协议，去地址为www.joes-hardware.com的这个服务器，获取服务器下路径为<code>/seasonal/index-fall.html</code>的资源</strong></p><h3 id="url语法" tabindex="-1"><a class="header-anchor" href="#url语法" aria-hidden="true">#</a> URL语法</h3><div class="language-ruby line-numbers-mode" data-ext="rb"><pre class="language-ruby"><code><span class="token operator">&lt;</span>scheme<span class="token operator">&gt;</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span><span class="token operator">:</span><span class="token operator">&lt;</span>password<span class="token operator">&gt;</span>@<span class="token operator">&lt;</span>host<span class="token operator">&gt;</span><span class="token operator">:</span><span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token operator">/</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span>params<span class="token operator">&gt;</span><span class="token operator">?</span> <span class="token operator">&lt;</span>query<span class="token operator">&gt;</span><span class="token comment">#&lt;frag&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最重要的三部分</p><ol><li>方案scheme： 方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL的其余部分分隔开来。方案名是大小写无关的</li><li>主机host：</li><li>路径path：</li></ol><p>其余</p><ol><li><p>参数params：负责解析URL的应用程序需要这些协议参数来访问资源</p></li><li><p>查询字符串query：==URL的查询组件==和标识网关资源的URL路径组件一起被发送给网关资源</p></li><li><p>片段：使用片段（frag）组件来表示一个资源内部的片段。比如，URL可以指向HTML文档中一个特定的图片或小节。片段挂在URL的右手边，最前面有一个字符“#”</p><p>==HTTP服务器通常只处理整个对象，而不是对象的片段==，客户端不能将片段传送给服务器（参见图2-3）。浏览器从服务器获得了整个资源之后，会根据片段来显示你感兴趣的那部分资源</p></li></ol><h3 id="相对url" tabindex="-1"><a class="header-anchor" href="#相对url" aria-hidden="true">#</a> 相对URL</h3><p>URL有两种方式：绝对的和相对的。到目前为止，我们只见过绝对URL。==绝对URL中包含有访问资源所需的全部信息==。</p><h3 id="编码机制" tabindex="-1"><a class="header-anchor" href="#编码机制" aria-hidden="true">#</a> 编码机制</h3><p>为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来<strong>在URL中表示各种不安全的字符</strong>。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，==这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数==</p><ol><li>%7E： <code>~</code>字符</li><li>%20: <code>空格</code>符</li><li>%25：<code>%</code>字符</li></ol><h2 id="http-1-1持久连接" tabindex="-1"><a class="header-anchor" href="#http-1-1持久连接" aria-hidden="true">#</a> HTTP/1.1持久连接</h2><p>除非响应中包含了1Connection：close首部，否则HTTP/1.1连接就仍维持在打开状态</p><h2 id="管道化连接" tabindex="-1"><a class="header-anchor" href="#管道化连接" aria-hidden="true">#</a> 管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用请求管道</p><p>==在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。==</p><p>对管道化连接有几条限制。</p><ol><li>如果HTTP客户端<strong>无法确认连接是持久的，就不应该使用管道。</strong></li><li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li><li><strong>HTTP客户端必须做好连接会在任意时刻关闭的准备</strong>，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了10条请求，服务器可能在只处理了，比方说，5条请求之后关闭连接。剩下的5条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li><li><strong>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）</strong>。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li></ol><h2 id="关闭连接" tabindex="-1"><a class="header-anchor" href="#关闭连接" aria-hidden="true">#</a> 关闭连接</h2><p>对管道化持久连接来说，HTTP应用程序可以在经过任意一段时间之后，关闭持久连接</p><h2 id="代理" tabindex="-1"><a class="header-anchor" href="#代理" aria-hidden="true">#</a> 代理</h2><h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><p>==Web缓存是可以自动保存常见文档副本的HTTP设备==。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。</p><p>使用缓存有下列优点。</p><ol><li><strong>减少了冗余的数据传输</strong>，节省了你的网络费用。</li><li><strong>缓解了网络瓶颈的问题</strong>。不需要更多的带宽就能够更快地加载页面。</li><li><strong>降低了对原始服务器的要求</strong>。服务器可以更快地响应，避免过载的出现。</li><li><strong>降低了距离时延</strong>，因为从较远的地方加载页面会更慢一些。</li></ol><h2 id="客户端识别与cookie机制" tabindex="-1"><a class="header-anchor" href="#客户端识别与cookie机制" aria-hidden="true">#</a> 客户端识别与cookie机制</h2><h4 id="cgi" tabindex="-1"><a class="header-anchor" href="#cgi" aria-hidden="true">#</a> CGI</h4><p>Common Gateway Interface: 公共网关接口，CGI是一种通过Web服务器与外部应用程序之间通信的标准接口协议，它允许Web浏览器发送请求到Web服务器，并将用户输入与服务器端执行的程序进行交互。通过CGI技术，可以实现动态生成网页、处理表单数据、访问数据库等功能。CGI程序是基于脚本语言编写的，常用的有Perl、Python、PHP等语言。</p><p>Computer-generated imagery：电脑三微动画</p><h4 id="一、lf和crlf是什么" tabindex="-1"><a class="header-anchor" href="#一、lf和crlf是什么" aria-hidden="true">#</a> 一、LF和CRLF是什么</h4><blockquote><p>CRLF 是 <strong>carriage return line feed</strong> 的缩写，中文意思是回车换行。</p><p>LF 是 <strong>line feed</strong> 的缩写，中文意思也是换行。</p><p>它们都是文本换行的方式。</p></blockquote><h4 id="二、lf和crlf区别" tabindex="-1"><a class="header-anchor" href="#二、lf和crlf区别" aria-hidden="true">#</a> 二、LF和CRLF区别</h4><p><code>CRLF</code>: &quot;\\r\\n&quot;, windows系统环境下的换行方式</p><p><code>LF</code>: &quot;\\n&quot;, Linux系统环境下的换行方式</p><p>其他没啥区别的。</p><h1 id="http结构" tabindex="-1"><a class="header-anchor" href="#http结构" aria-hidden="true">#</a> HTTP结构</h1><h2 id="_1-web服务器" tabindex="-1"><a class="header-anchor" href="#_1-web服务器" aria-hidden="true">#</a> 1.Web服务器</h2><p>服务器请求的步骤</p><ol><li><p>接受客户端连接</p><p>客户端请求一条到Web服务器的TCP连接时，Web服务器会建立连接，判断连接的另一端是哪个客户端，从TCP连接中将IP地址解析出来。[插图]一旦新连接建立起来并被接受，服务器就会将新连接添加到其现存Web服务器连接列表中，做好监视连接上数据传输的准备。</p></li><li><p>接收请求报文</p><p>解析请求行查找请求方法、URL以及版本号</p><p>读取首部</p><p>（如果有的话）读取请求主体</p></li><li><p>处理请求</p></li><li><p>对资源的映射及访问</p><p>将内容传送给客户端前，将请求报文中的URL<strong>映射</strong>为Web服务器上适当的内容或内容生成器，以识别出内容的源头</p><p><strong>映射</strong>：Web服务器支持各种不同类型的资源映射，但最简单的资源映射形式就是<strong>用请求URI作为名字来访问Web服务器文件系统中的文件</strong></p></li></ol><p>​ 动态内容资源的映射</p><p>​ Web服务器还可以将URI映射为动态资源，映射到按需动态生成内容的程序上去</p><p>​ <strong>访问控制</strong></p><ol start="5"><li><p>构建响应</p><p>如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。如果有响应主体的话，</p><p>响应报文中通常包括：·</p><ol><li>描述了响应主体MIME类型的Content-Type首部</li><li>描述了响应主体长度的Content-Length首部</li><li>实际报文的主体内容</li></ol><p><strong>重定向</strong></p><p>Web服务器可以将浏览器重定向到其他地方来执行请求。重定向响应由返回码3XX说明。Location响应首部包含了内容的新地址或优选地址的URI</p></li><li><p>发送响应</p><p>服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要特别小心，要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了</p></li><li><p>记录日志</p><p>当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务</p></li></ol><h2 id="_2-代理" tabindex="-1"><a class="header-anchor" href="#_2-代理" aria-hidden="true">#</a> 2.代理</h2><p>Web代理（proxy）服务器是网络的中间实体。代理位于客户端和服务器之间，代表客户端完成事务处理，扮演“中间人”的角色，在各端点之间来回传送HTTP报文。</p><p>HTTP的代理服务器既是Web服务器又是Web客户端。</p><h4 id="_2-1-代理和网关的区别" tabindex="-1"><a class="header-anchor" href="#_2-1-代理和网关的区别" aria-hidden="true">#</a> 2.1 代理和网关的区别</h4><p>严格来说，代理连接的是两个或多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的端点。==网关扮演的是“协议转换器”的角色==</p><h4 id="_2-2-为什么要用代理" tabindex="-1"><a class="header-anchor" href="#_2-2-为什么要用代理" aria-hidden="true">#</a> 2.2 为什么要用代理</h4><p>改善安全性，提高性能，节省费用，常用于：</p><ol><li>过滤内容</li><li>文档访问控制</li><li>安全防火墙</li><li>Web缓存</li><li>反向代理：反向代理通常会直接冒用Web服务器的名字和IP地址，这样所有的请求就会被发送给代理而不是服务器了</li><li>转码器</li><li>内容路由器</li><li>匿名者：匿名者代理会主动从HTTP报文中删除身份特性（比如客户端IP地址、From首部、Referer首部、cookie、URI的会话ID），从而提供高度的私密性和匿名性</li></ol><h4 id="_2-3-代理的层次结构" tabindex="-1"><a class="header-anchor" href="#_2-3-代理的层次结构" aria-hidden="true">#</a> 2.3 代理的层次结构</h4><p>在代理的层次结构中，会将报文从一个代理传给另一个代理，直到最终抵达原始服务器为止（然后通过代理传回给客户端）。</p><p>Proxy层次结构中的代理服务器被赋予了父（parent）和子（child）的关系。</p><p>下一个入口（inbound）代理**（靠近服务器）被称为父代理**，</p><p>下一个出口（outbound）代理**（靠近客户端）被称为子代理**</p><p><strong>动态选择父代理</strong></p><ol><li><p>负载均衡</p><p>子代理可能会根据当前父代理上的工作负载级别来决定如何选择一个父代理，以均衡负载。</p></li><li><p>地理位置附近的路由</p><p>子代理可能会选择负责原始服务器所在物理区域的父代理。</p></li><li><p>协议/类型路由</p><p>子代理可能会根据URI将报文转发到不同的父代理和原始服务器上去。某些特定类型的URI可能要通过一些特殊的代理服务器转发请求，以便进行特殊的协议处理。</p></li><li><p>基于订购的路由</p><p>如果发布者为高性能服务额外付费了，它们的URI就会被转发到大型缓存或压缩引擎上去，以提高性能。</p><p>在不同的产品中，动态父路由逻辑的实现方式各有不同，包括使用配置文件、脚本语言和动态可执行插件等。</p></li></ol><h4 id="_2-4-via首部和-server首部" tabindex="-1"><a class="header-anchor" href="#_2-4-via首部和-server首部" aria-hidden="true">#</a> 2.4 Via首部和 Server首部</h4><p>​ Via首部字段用于==记录报文的转发，诊断报文循环，标识请求/响应链上所有发送者的协议能力==，列出了<strong>与报文途经的每个中间节点（代理或网关）有关的信息。报文每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。</strong></p><p>​ Server响应首部字段==对原始服务器使用的软件进行了描述==，如果响应报文是通过代理转发的，一定要确保代理没有修改Server首部。Server首部是用于原始服务器的。代理应该添加的是Via条目。</p><h4 id="_2-5-trace方法" tabindex="-1"><a class="header-anchor" href="#_2-5-trace方法" aria-hidden="true">#</a> 2.5 TRACE方法</h4><p>通过HTTP/1.1的TRACE方法，用户可以跟踪经代理链传输的请求报文，观察报文经过了哪些代理，以及每个代理是如何对请求报文进行修改的。TRACE对代理流的调试非常有用。</p><p>Max-Forwards（最大转发次数）首部：可以使用Max-Forwards（最大转发次数）首部来<strong>限制TRACE和OPTIONS请求所经过的代理跳数</strong></p><h4 id="_2-6-代理认证" tabindex="-1"><a class="header-anchor" href="#_2-6-代理认证" aria-hidden="true">#</a> 2.6 代理认证</h4><p>代理可以==作为访问控制设备使用==。HTTP定义了一种名为代理认证（proxy authentication）的机制，这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限证书为止。</p><p>对受限内容的请求到达一台代理服务器时，代理服务器可以返回一个要求使用访问证书的<strong>407 Proxy Authorization Required状态码</strong>，以及一个用于<strong>描述怎样提供这些证书的Proxy-Authenticate首部字段</strong></p><h4 id="_2-7-options方法" tabindex="-1"><a class="header-anchor" href="#_2-7-options方法" aria-hidden="true">#</a> 2.7 OPTIONS方法</h4><p>客户端（或代理）可以<strong>发现Web服务器或者其上某个特定资源所支持的功能</strong>（比如，它们所支持的方法），可以在与服务器进行交互之前，<strong>确定服务器的能力</strong>。</p><p>==OPTIONS请求的URI是个星号（＊），请求的就是整个服务器所支持的功能==</p><h5 id="响应中的allow首部-列出了请求uri标识的资源所支持的方法列表-uri为-的话-列出的就是整个服务器所支持的方法列表" tabindex="-1"><a class="header-anchor" href="#响应中的allow首部-列出了请求uri标识的资源所支持的方法列表-uri为-的话-列出的就是整个服务器所支持的方法列表" aria-hidden="true">#</a> 响应中的Allow首部：列出了请求URI标识的资源所支持的方法列表，URI为＊的话，列出的就是整个服务器所支持的方法列表</h5><h2 id="_3-缓存" tabindex="-1"><a class="header-anchor" href="#_3-缓存" aria-hidden="true">#</a> 3.缓存</h2><p>Web缓存是可以自动保存常见文档副本的HTTP设备</p><p>减少冗余数据传输，多个客户端同时访问一个资源时，保存第一条服务器响应的副本</p><p>破坏瞬间拥塞，防止巨大的流量同时冲击服务器，服务器产生灾难性的崩溃</p><p>减少距离时延</p><h4 id="_3-1-再验证" tabindex="-1"><a class="header-anchor" href="#_3-1-再验证" aria-hidden="true">#</a> 3.1 再验证</h4><p>原始服务器的内容可能会发生变化，<strong>缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本</strong>。这些“新鲜度检测”被称为HTTP再验证（revalidation）</p><p>大部分缓存只有在客户端发起请求，并且副本<strong>旧得足以需要检测的时候，才会对副本进行再验证</strong></p><p>缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，<strong>服务器会以一个小的304 Not Modified进行响应。</strong></p><h4 id="使用if-modified-since首部进行再验证" tabindex="-1"><a class="header-anchor" href="#使用if-modified-since首部进行再验证" aria-hidden="true">#</a> 使用if-Modified-Since首部进行再验证</h4><ol><li><p>再验证命中如果服务器<strong>对象未被修改</strong></p><p>服务器会向客户端发送一个小的HTTP 304 Not Modified响应。</p></li><li><p>再验证未命中如果<strong>服务器对象与已缓存副本不同</strong></p></li></ol><p>服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应。</p><ol start="3"><li><p>对象被删除如果服务器<strong>对象已经被删除了</strong>：</p><p>服务器就回送一个404 Not Found响应，缓存也会将其副本删除。</p></li></ol><h4 id="_3-2-缓存处理过程的步骤" tabindex="-1"><a class="header-anchor" href="#_3-2-缓存处理过程的步骤" aria-hidden="true">#</a> 3.2 缓存处理过程的步骤</h4><ol><li>接收网络上的请求报文</li><li>解析请求报文</li><li>查询本地副本，根据情形和配置，到原始服务器或父代理去取，或者返回错误信息</li><li>新鲜度检测（再验证）： 客户端发送给缓存的所有 请求首部自身 都可以<strong>强制缓存进行再验证</strong></li><li>创建响应：缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。缓存还会向其中插入新鲜度信息（Cache-Control、Age以及Expires首部），而且<strong>通常会包含一个Via首部来说明请求是由一个代理缓存提供的</strong>。==注意，缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。==</li><li>发送响应</li><li>记录日志</li></ol><h4 id="_3-3-保持副本的新鲜" tabindex="-1"><a class="header-anchor" href="#_3-3-保持副本的新鲜" aria-hidden="true">#</a> 3.3 保持副本的新鲜</h4><p><strong>3.3.1 文档过期机制</strong></p><p>​ HTTP通过<strong>Cache-Control首部（HTTP/1.1）<strong>和</strong>Expires首部（HTTP/1.0+）</strong>，让原始服务器为每个文档附加过期日期</p><p>​ Cache-Control首部使用相对时间，max-age=xxxx(以秒为单位)</p><p>​ Expires首部指定一个绝对的过期日期</p><p><strong>3.3.2 服务器再验证机制</strong></p><p>​ 文档过期只表示到了需要进行核对的时间，实际的缓存文档和原始服务器上的文档不一定有实际区别</p><ol><li>如果再验证显示内容 发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li><li>如果再验证显示内容 没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。</li></ol><p><strong>3.3.3 条件方法再验证</strong></p><p>​ 缓存向服务器发送一个”条件GET“请求，只有当服务器的文档与缓存中现有副本不同时，才返回对象主体</p><h4 id="条件请求首部-1" tabindex="-1"><a class="header-anchor" href="#条件请求首部-1" aria-hidden="true">#</a> 条件请求首部</h4><ol><li><h4 id="if-modified-since-与服务器响应首部last-modified配合使用" tabindex="-1"><a class="header-anchor" href="#if-modified-since-与服务器响应首部last-modified配合使用" aria-hidden="true">#</a> if-Modified-Since： 与服务器响应首部Last-Modified配合使用</h4><p>If-Modified-Since再验证请求通常被称为<strong>IMS请求</strong>。==只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求==</p><p>如果自指定日期后，文档被修改了，<strong>If-Modified-Since条件就为真，通常GET就会成功执行</strong>。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</p></li><li><h4 id="if-none-match-与实体标签etag配合使用-实体标签再验证" tabindex="-1"><a class="header-anchor" href="#if-none-match-与实体标签etag配合使用-实体标签再验证" aria-hidden="true">#</a> if-None-Match： 与实体标签Etag配合使用（实体标签再验证）</h4></li></ol><p>​ 对以下情况，仅使用最后修改日期进行验证时不够的</p><ol><li>文档可能被周期性重写，但实际包含的数据常常是没有变化的，仅仅是修改日期会变化</li><li>某些文件修改非常频繁，1秒内修改了N次，If-Modified-Since能检查到的粒度是秒级的，这种修改无法判断</li><li>有些文档可能被修改了，但所做修改并不重要，不需要让大范围的缓存重装数据</li><li>有些服务器无法准确判断页面的最后修改日期</li></ol><h4 id="_4-强弱验证器" tabindex="-1"><a class="header-anchor" href="#_4-强弱验证器" aria-hidden="true">#</a> 4.强弱验证器</h4><p>弱验证器允许对一些内容进行修改，但内容的主要含义发生变化时，通常它还是会变化的。有些操作不能用弱验证器来实现（比如有条件地获取部分内容），所以，服务器会用前缀“W/”来标识弱验证器</p><p>只要内容发生了变化，强验证器就会变化。</p><p>如果HTTP/1.1缓存或服务器收到的请求既带有If-Modified-Since，又带有实体标签条件首部，那么只有这两个条件都满足时，才能返回304 Not Modified响应。</p><h4 id="_5-缓存控制" tabindex="-1"><a class="header-anchor" href="#_5-缓存控制" aria-hidden="true">#</a> 5. 缓存控制</h4><ol><li><h5 id="no-store首部和no-cache首部" tabindex="-1"><a class="header-anchor" href="#no-store首部和no-cache首部" aria-hidden="true">#</a> no-store首部和no-cache首部</h5></li></ol><p>防止缓存提供未经证实的已缓存对象</p><p>标识为==no-store的响应会禁止缓存对响应进行复制==。缓存通常会像非缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。</p><p>标识为==no-cache的响应实际上是可以存储在本地缓存区中的==。==<strong>只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用</strong>==。这个首部使用do-not-serve-from-cache-without-revalidation这个名字会更恰当一些。</p><ol start="2"><li><h5 id="max-age响应首部" tabindex="-1"><a class="header-anchor" href="#max-age响应首部" aria-hidden="true">#</a> max-age响应首部</h5><p>Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。</p></li><li><h5 id="must-revalidate响应首部" tabindex="-1"><a class="header-anchor" href="#must-revalidate响应首部" aria-hidden="true">#</a> must-revalidate响应首部</h5><p>Cache-Control: must-revalidate响应首部告诉缓存，==在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本==。缓存仍然可以随意提供新鲜的副本。==如果在缓存进行must-revalidate新鲜度检查时，原始服务器不可用，缓存就必须返回一条504 Gateway Timeout错误。==</p></li></ol><h3 id="_5-虚拟主机" tabindex="-1"><a class="header-anchor" href="#_5-虚拟主机" aria-hidden="true">#</a> 5.虚拟主机</h3><h1 id="http-ng-http-2-0" tabindex="-1"><a class="header-anchor" href="#http-ng-http-2-0" aria-hidden="true">#</a> HTTP-NG（HTTP/2.0）</h1><h3 id="_1-模块化及功能增强" tabindex="-1"><a class="header-anchor" href="#_1-模块化及功能增强" aria-hidden="true">#</a> 1.模块化及功能增强</h3><p>HTTP-NG工作组建议将协议模块化为三层</p><ol><li><h4 id="报文传输层-使用webmux的协议-webmux是个高性能的报文协议-可以对报文进行分段-并在一条复用的tcp连接上交错地传输报文" tabindex="-1"><a class="header-anchor" href="#报文传输层-使用webmux的协议-webmux是个高性能的报文协议-可以对报文进行分段-并在一条复用的tcp连接上交错地传输报文" aria-hidden="true">#</a> 报文传输层：使用WebMUX的协议（WebMUX是个高性能的报文协议，可以对报文进行分段，并在一条复用的TCP连接上交错地传输报文）</h4><p>报文传输层不考虑报文的功能、含义和目的，关心的是报文的有效传输和不透明传输。为报文传输提供了一个API，无论底层实际采用的是什么网络协议栈都可以使用。</p><p><strong>提高报文传输的性能，包括以下：</strong></p><p>​ <em>对报文进行管道化和批量化传输，以降低往返时延；</em></p><p>​ <em>重用连接，以降低时延，提高传输带宽；</em></p><p>​ <em>在同一条连接上并行地复用多个报文流，在防止报文流饿死的同时优化共享连接；</em></p><p>​ <em>对报文进行有效的分段，使报文边界的确定更加容易。</em></p></li><li><h3 id="远程调用层-二进制连接协议" tabindex="-1"><a class="header-anchor" href="#远程调用层-二进制连接协议" aria-hidden="true">#</a> 远程调用层：二进制连接协议</h3><p>定义了请求/响应的功能，客户端可以通过这些功能调用对服务器资源的操作，</p><p>HTTP-NG结构的中间层提供了对远程方法调用的支持。<strong>本层提供了通用的请求/响应框架，客户端可通过此框架调用对服务器资源的操作</strong>。本层并不关心特定操作的实现及语义（缓存、安全性以及方法逻辑等）；它只关心允许客户端远程调用服务器操作的接口。</p></li><li><h4 id="web应用层" tabindex="-1"><a class="header-anchor" href="#web应用层" aria-hidden="true">#</a> Web应用层：</h4><p>提供了大部分的内容管理逻辑。所有的HTTP/1.1方法（GET、POST、PUT等）以及HTTP/1.1首部参数都是在这里定义的</p><p>描述了一个用于提供应用程序特定服务的系统，Web应用层的基本思想是提供与HTTP/1.1等价的功能和一些扩展接口，同时将其映射到一个可扩展的分布式对象框架中去</p></li></ol><h3 id="_2-webmux" tabindex="-1"><a class="header-anchor" href="#_2-webmux" aria-hidden="true">#</a> 2.WebMUX</h3><p>​ 目标</p><ol><li>设计简单，高性能</li><li>复用：可以在一条连接上动态、高效地交错传递多个（使用任意高层协议的）数据流，<strong>不用因为等待那些速度很慢的生产者程序而延迟数据的传输。</strong></li><li>基于信用的流量控制：数据是以不同的速率产生和消耗的，发送者和接收者的内存和可用的CPU资源都有所不同。接收者可以预先声明期望的数据接收速度，<strong>防止出现资源缺乏产生的死锁。</strong></li><li>保持复用流中数据的对齐，这样<strong>才能有效地发送并处理二进制数据。</strong></li><li><strong>接口足够丰富</strong>，能支持套接字API</li></ol><h3 id="_3-二进制连接协议" tabindex="-1"><a class="header-anchor" href="#_3-二进制连接协议" aria-hidden="true">#</a> 3.二进制连接协议</h3><p>​ 二进制连接协议<strong>通过一条有状态的连接承载了从客户端发往服务器的操作调用请求，以及从服务器发往客户端的操作结果应答</strong>。有状态的连接可以提供更高的效率。</p><h3 id="_4-客户端识别和cookie机制" tabindex="-1"><a class="header-anchor" href="#_4-客户端识别和cookie机制" aria-hidden="true">#</a> 4.客户端识别和cookie机制</h3><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> cookie</h3><p>​ 会话cookie</p><p>​ 持久cookie</p><p>cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它</p><h2 id="基本认证机制" tabindex="-1"><a class="header-anchor" href="#基本认证机制" aria-hidden="true">#</a> 基本认证机制</h2><p>基本认证、摘要认证</p><h3 id="_1-认证" tabindex="-1"><a class="header-anchor" href="#_1-认证" aria-hidden="true">#</a> 1.认证</h3><p>HTTP提供了一个原生的质询/响应（challenge/response）框架，简化了对用户的认证过程。</p><p><strong>认证协议与首部</strong></p><ol><li><p>质询 WWW-Authenticate首部：</p><p>服务器对用户进行质询时，会返回一条401 Unauthorized响应，并<strong>在WWW-Authenticate首部说明如何以及在哪里进行认证</strong></p></li><li><p>授权 Authorization首部：</p><p>当客户端授权服务器继续处理时，会重新发送请求，但会<strong>在Authorization首部附上加密的密码和其他一些认证参数</strong></p></li><li><p>成功 Authentication-Info首部：</p><p>授权请求成功完成时，服务器会返回一个正常的状态码（200 OK）；对高级认证算法来说，可能<strong>还会在Authentication-Info首部附加一些额外的信息</strong></p></li></ol><p><strong>安全</strong></p><p>​ Web服务器会将受保护的文档组织成一个安全域（security realm）。每个安全域都可以有不同的授权用户集。</p><h2 id="_2-基本认证" tabindex="-1"><a class="header-anchor" href="#_2-基本认证" aria-hidden="true">#</a> 2.基本认证</h2><p>在基本认证中，Web服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。<strong>服务器会返回401状态码，而不是200状态码来初始化认证质询，并用WWW-Authenticate响应首部指定要访问的安全域</strong>。浏览器收到质询时，会打开一个对话框，请求<strong>用户输入这个域的用户名和密码。然后将用户名和密码稍加扰码，再用Authorization请求首部回送给服务器。</strong></p><h4 id="_2-1-代理认证" tabindex="-1"><a class="header-anchor" href="#_2-1-代理认证" aria-hidden="true">#</a> 2.1 代理认证</h4><h4 id="_2-2-基本认证的安全缺陷" tabindex="-1"><a class="header-anchor" href="#_2-2-基本认证的安全缺陷" aria-hidden="true">#</a> 2.2.基本认证的安全缺陷</h4><ol><li>通过网络发送用户名和密码，密码是以明文传输，虽然通过Base-64编码，但也有被捕获和被解码的风险</li><li>没有针对任何中间节点的防护措施，没有修改认证首部，而是修改报文其余部分，严重影响了事务的本质</li><li>假冒服务器可以骗过基本认证，窃取用户密码</li></ol><p>总之，基本认证便捷灵活，但极不安全。用户名和密码都是以明文形式传送的，也没有采取任何措施防止对报文的篡改。<strong>安全使用基本认证的唯一方式就是将其与SSL配合使用。</strong></p><h2 id="_3-摘要认证" tabindex="-1"><a class="header-anchor" href="#_3-摘要认证" aria-hidden="true">#</a> 3.摘要认证</h2><h3 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>在对称密钥加密技术中，<strong>==发送端和接收端要共享相同的密钥k才能进行通信==</strong>。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文</p><h3 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h3><p>用公钥加密的内容只能用私钥解密，用私钥加密的内容只能用公钥解密</p><h3 id="数字签名" tabindex="-1"><a class="header-anchor" href="#数字签名" aria-hidden="true">#</a> 数字签名</h3><p>用加密系统对报文进行签名（sign），以说明是谁编写的报文，同时证明报文未被篡改过。是用非对称加密技术产生</p><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2><p>HTTPS就是在安全的传输层上发送的HTTP。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得HTTPS不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理。</p><h1 id="跨域及解决方法" tabindex="-1"><a class="header-anchor" href="#跨域及解决方法" aria-hidden="true">#</a> 跨域及解决方法</h1><p>浏览器同源策略：两个URL中，协议，域名，端口号都相同，就称这两个URL同源，否则只要协议，域名，端口号任何一个不同，就被当成不同的域</p><h3 id="为什么有同源策略" tabindex="-1"><a class="header-anchor" href="#为什么有同源策略" aria-hidden="true">#</a> <strong>为什么有同源策略</strong>：</h3><p>浏览器默认两个相同的源之间是<strong>可以互相访问资源和操作DOM</strong></p><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><ol><li>DOM层面：限制来自不同源的JavaScript脚本对当前DOM对象读和写的操作</li><li>数据层面：限制不同源的站点读取当前站点的Cookie、indexDB、LocalStorage等方案。</li><li>网络层面：限制了通过XHR等方式将站点数据发送给不同的源</li></ol><p>简单请求成立的条件：</p><ol><li>请求方法只能是GET、POST、HEAD</li><li>请求头限制 Accept、Accept-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width</li><li>Content-Type：只能取application/x-www-form-urlencoded、multipart/form-data、text/plain这特定的3个</li><li>请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用</li><li>请求中没有使用ReadableStream对象</li></ol><h3 id="_1-对于简单请求" tabindex="-1"><a class="header-anchor" href="#_1-对于简单请求" aria-hidden="true">#</a> 1.对于简单请求：</h3><p>不管是否跨域，浏览器都直接放行，<strong>请求可以发出并被服务器处理，但是返回的响应会被浏览器拦截</strong>，浏览器会检查响应头中的Access-Control-Allow-Origin是否包含该请求的域</p><p>==<strong>解决方案： 服务器的响应头中加上允许跨域的首部&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;</strong>==</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//通过路由，提供一个get的查询服务</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 支持保证跨域</span>
   res<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;Hello World 8881&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-对于复杂请求" tabindex="-1"><a class="header-anchor" href="#_2-对于复杂请求" aria-hidden="true">#</a> 2.对于复杂请求：</h3><p>​ 1）浏览器会在发起正式请求前，<strong>先发出一个OPTIONS请求给服务器，这个请求被称为Preflighted Requests（预检请求）</strong>，</p><p>​ 2）浏览器收到 preflight response（预检请求的响应）后，检查响应头中的Access-Control-Allow-Origin, Access-Control-Allow-Headers以及其他Access-Control-*类的headers</p><p>​ 3）如果该请求符合要求，就能正常发出请求并获取响应结果，如果<strong>不符合要求，则请求无法发出</strong></p><p>==**解决方案：对于nodejs来说，采取了路由，配置app.all()响应所有请求（目的是options请求也能被服务器处理）并设置Access-Control-Allow-Origin, Access-Control-Allow-Headers以及其他Access-Control-*类的headers **==</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;/public&#39;</span><span class="token punctuation">,</span> express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span><span class="token string">&#39;public&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//在aap.use后面新增一个基础路由，由于是all，因此options也会进去</span>
app<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token string">&#39;*&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Origin, X-Requested-With, Content-Type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;POST, GET, PUT, OPTIONS, DELETE&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="强缓存和协商缓存" tabindex="-1"><a class="header-anchor" href="#强缓存和协商缓存" aria-hidden="true">#</a> 强缓存和协商缓存</h1><p>HTTP中的缓存是一种用于提高性能和减少网络带宽使用的机制。HTTP缓存分为两种主要类型：强缓存和协商缓存。</p><p><strong>强缓存（HTTP Cache）</strong>：</p><p>强缓存是一种机制，用于告诉浏览器或客户端，可以直接从本地缓存中获取资源，而不需要向服务器发起请求。这是通过在HTTP响应头中设置特定的缓存标头来实现的，最常用的是<code>Cache-Control</code>和<code>Expires</code>。</p><ol><li><strong>Cache-Control</strong>：<code>Cache-Control</code>是HTTP响应头的一个指令，用于控制缓存的行为。常见的<code>Cache-Control</code>指令包括： <ul><li><code>max-age</code>：指定缓存资源的有效期，以秒为单位。例如，<code>max-age=3600</code>表示资源在缓存中有效期为1小时。</li><li><code>public</code>：允许中间代理服务器（如CDN）缓存资源。</li><li><code>private</code>：只允许终端用户的浏览器缓存资源。</li><li><code>no-cache</code>：要求客户端在使用缓存之前验证资源的有效性。</li></ul></li><li><strong>Expires</strong>：<code>Expires</code>是另一个控制缓存的响应头，它指定了资源的过期日期和时间。它的值是一个GMT格式的日期字符串。例如，<code>Expires: Wed, 21 Oct 2023 07:28:00 GMT</code>表示资源在指定日期之后将过期。</li></ol><p>当浏览器或客户端发起请求时，它会检查缓存标头，如果资源仍然有效（即未过期），则可以直接从缓存中获取资源，而不需要向服务器发起请求。</p><p><strong>协商缓存（Conditional Cache）</strong>：</p><p>协商缓存是一种机制，用于在资源过期或需要重新验证时，向服务器发起条件性请求以确定是否需要获取新的资源。协商缓存使用HTTP请求头如<code>If-Modified-Since</code>和<code>If-None-Match</code>，以及响应头如<code>Last-Modified</code>和<code>ETag</code>。</p><ol><li><strong>Last-Modified 和 If-Modified-Since</strong>：服务器在响应中发送<code>Last-Modified</code>头，指示资源的最后修改时间。当客户端再次请求资源时，它可以在请求头中包含<code>If-Modified-Since</code>，表示如果资源自指定日期以来未修改，那么就可以使用缓存。服务器会检查资源的修改日期，如果未发生变化，将返回304 Not Modified响应，表示资源未被修改，客户端可以使用缓存。</li><li><strong>ETag 和 If-None-Match</strong>：类似于<code>Last-Modified</code>，服务器在响应中发送<code>ETag</code>头，它是资源的唯一标识符。客户端在请求头中包含<code>If-None-Match</code>，表示如果资源的<code>ETag</code>仍然相同，那么可以使用缓存。服务器会比较资源的<code>ETag</code>与请求中的<code>If-None-Match</code>，如果相同，将返回304 Not Modified响应。</li></ol><p>协商缓存允许客户端和服务器在资源发生变化时有效地管理缓存，而不需要每次都重新下载资源。</p><p>综上所述，强缓存和协商缓存是HTTP中用于优化资源加载的两种重要机制，它们可以显著提高网站性能和减少服务器负载。通过适当配置缓存标头，可以实现更高效的资源管理。</p>`,230),r=[i];function o(p,d){return e(),n("div",null,r)}const h=a(t,[["render",o],["__file","Http.html.vue"]]);export{h as default};
